### 算法题分类

在做算法题时  首先需要对算法题进行一个基本归类

- 题目类型基本归类
- 题目难易程度推算
- 大概了解考察的是什么内容


大概分为以下几类

1、略简单，但是主要考察的是细心，可能会有10+种情况需要考虑
2、如果使用一些语言自带的API 可能会快速解题，这是一种重要的思路，但也需要常规的数据结构解法
3、反方向进行推算，倒过来推算


### 递归题

**递归程序的基本步骤**

(1) 初始化算法。递归程序通常需要一个开始时使用的种子值（seed value）。要完成此任务，可以向函数传递参数，或者提供一个入口函数， 这个函数是非递归的，但可以为递归计算设置种子值。
(2) 检查要处理的当前值是否已经与基线条件相匹配。如果匹配，则进行处理并返回值。
(3) 使用更小的或更简单的子问题（或多个子问题）来重新定义答案。
(4) 对子问题运行算法。
(5) 将结果合并入答案的表达式。
(6) 返回结果。

```
const add = (s)=>{
  // 递归出口
  if(s>=100){
    return s;
  }
  s++;  // 递归因素变化
  //  继续深入递归
  return s + add(s)
  
}
```

**递归中的回溯算法**

基本思想

在包含问题的所有解的解空间树中，按照深度优先搜索的策略，从根结点出发深度探索解空间树。当探索到某一结点时，要先判断该结点是否包含问题的解，如果包含，就从该结点出发继续探索下去，如果该结点不包含问题的解，则逐层向其祖先结点回溯。（其实回溯法就是对隐式图的深度优先搜索算法）。

       若用回溯法求问题的所有解时，要回溯到根，且根结点的所有可行的子树都要已被搜索遍才结束。

       而若使用回溯法求任一个解时，只要搜索到问题的一个解就可以结束。






### 排列组合

**排列**
```
A(3,4) = 4!/3!
```
**组合**
```
C(4,3) = 4!/(4-3)!*3!
```